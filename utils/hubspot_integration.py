"""
HubSpot CRM Integration
Handles bidirectional sync between lead enrichment system and HubSpot
"""

import os
import requests
from typing import Dict, List, Optional
from datetime import datetime
from dotenv import load_dotenv

load_dotenv()

class HubSpotIntegration:
    """Integration class for HubSpot CRM"""
    
    def __init__(self, api_key: Optional[str] = None):
        """
        Initialize HubSpot integration
        
        Args:
            api_key: HubSpot API key (defaults to HUBSPOT_API_KEY env var)
        """
        self.api_key = api_key or os.getenv('HUBSPOT_API_KEY')
        if not self.api_key:
            raise ValueError("HubSpot API key is required. Set HUBSPOT_API_KEY in .env file.")
        
        self.base_url = "https://api.hubapi.com"
        self.headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }
    
    def create_custom_properties(self) -> Dict:
        """
        Create custom properties in HubSpot for enrichment data
        
        Returns:
            dict: Status of property creation
        """
        properties = [
            {
                "name": "enrichment_lead_score",
                "label": "Lead Score",
                "type": "number",
                "description": "Lead score calculated by enrichment system (0-100)"
            },
            {
                "name": "enrichment_score_category",
                "label": "Score Category",
                "type": "enumeration",
                "description": "Lead score category (High/Medium/Low)",
                "options": [
                    {"label": "High", "value": "High"},
                    {"label": "Medium", "value": "Medium"},
                    {"label": "Low", "value": "Low"}
                ]
            },
            {
                "name": "enrichment_temperature",
                "label": "Temperature",
                "type": "number",
                "description": "Current temperature in area"
            },
            {
                "name": "enrichment_weather_description",
                "label": "Weather Description",
                "type": "string",
                "description": "Current weather description"
            },
            {
                "name": "enrichment_median_income",
                "label": "Median Income",
                "type": "number",
                "description": "Area median household income"
            },
            {
                "name": "enrichment_percent_renters",
                "label": "Percent Renters",
                "type": "number",
                "description": "Percentage of renters in area"
            },
            {
                "name": "enrichment_population",
                "label": "Population",
                "type": "number",
                "description": "Area population"
            },
            {
                "name": "enrichment_insights",
                "label": "Market Insights",
                "type": "string",
                "description": "Market insights generated by enrichment system"
            },
            {
                "name": "enrichment_outreach_message",
                "label": "Outreach Message",
                "type": "string",
                "description": "Generated outreach message"
            },
            {
                "name": "enrichment_enriched_at",
                "label": "Enriched At",
                "type": "datetime",
                "description": "Timestamp of last enrichment"
            },
            {
                "name": "enrichment_enrichment_status",
                "label": "Enrichment Status",
                "type": "enumeration",
                "description": "Status of enrichment process",
                "options": [
                    {"label": "Success", "value": "Success"},
                    {"label": "Failed", "value": "Failed"},
                    {"label": "Pending", "value": "Pending"}
                ]
            }
        ]
        
        results = {}
        for prop in properties:
            try:
                url = f"{self.base_url}/crm/v3/properties/contacts"
                response = requests.post(url, headers=self.headers, json=prop)
                if response.status_code in [200, 201]:
                    results[prop['name']] = "Created"
                elif response.status_code == 409:
                    results[prop['name']] = "Already exists"
                else:
                    results[prop['name']] = f"Error: {response.text}"
            except Exception as e:
                results[prop['name']] = f"Exception: {str(e)}"
        
        return results
    
    def sync_lead_to_hubspot(self, lead_data: Dict, contact_id: Optional[str] = None) -> Dict:
        """
        Push enriched lead data to HubSpot
        
        Args:
            lead_data: Dictionary containing enriched lead data
            contact_id: Existing HubSpot contact ID (optional)
        
        Returns:
            dict: Response from HubSpot API
        """
        # Map enrichment data to HubSpot properties
        properties = {
            "enrichment_lead_score": lead_data.get('score'),
            "enrichment_score_category": lead_data.get('score_category', '').replace('ðŸŸ¢ ', '').replace('ðŸŸ¡ ', '').replace('ðŸ”´ ', ''),
            "enrichment_temperature": lead_data.get('temperature'),
            "enrichment_weather_description": lead_data.get('weather_description'),
            "enrichment_median_income": lead_data.get('median_income'),
            "enrichment_percent_renters": lead_data.get('percent_renters'),
            "enrichment_population": lead_data.get('population'),
            "enrichment_insights": lead_data.get('insights'),
            "enrichment_outreach_message": lead_data.get('outreach_message'),
            "enrichment_enriched_at": datetime.now().isoformat(),
            "enrichment_enrichment_status": "Success"
        }
        
        # Also update standard fields if available
        if lead_data.get('email'):
            properties['email'] = lead_data.get('email')
        if lead_data.get('name'):
            properties['firstname'] = lead_data.get('name').split()[0] if lead_data.get('name') else None
        if lead_data.get('company'):
            properties['company'] = lead_data.get('company')
        if lead_data.get('city'):
            properties['city'] = lead_data.get('city')
        if lead_data.get('state'):
            properties['state'] = lead_data.get('state')
        
        # Remove None values
        properties = {k: v for k, v in properties.items() if v is not None}
        
        if contact_id:
            # Update existing contact
            url = f"{self.base_url}/crm/v3/objects/contacts/{contact_id}"
            response = requests.patch(url, headers=self.headers, json={"properties": properties})
        else:
            # Create new contact
            url = f"{self.base_url}/crm/v3/objects/contacts"
            response = requests.post(url, headers=self.headers, json={"properties": properties})
        
        response.raise_for_status()
        return response.json()
    
    def get_hubspot_leads(self, filters: Optional[Dict] = None, limit: int = 100) -> List[Dict]:
        """
        Pull leads from HubSpot for enrichment
        
        Args:
            filters: Optional filters for querying contacts
            limit: Maximum number of contacts to retrieve
        
        Returns:
            list: List of contact dictionaries
        """
        url = f"{self.base_url}/crm/v3/objects/contacts"
        params = {
            "limit": limit,
            "properties": "email,firstname,lastname,company,city,state,country,enrichment_enriched_at"
        }
        
        # Add filters if provided
        if filters:
            # Build filter groups for HubSpot API
            filter_groups = []
            for key, value in filters.items():
                filter_groups.append({
                    "filters": [{
                        "propertyName": key,
                        "operator": value.get('operator', 'EQ'),
                        "value": value.get('value')
                    }]
                })
            params['filterGroups'] = filter_groups
        
        response = requests.get(url, headers=self.headers, params=params)
        response.raise_for_status()
        
        data = response.json()
        return data.get('results', [])
    
    def update_hubspot_contact(self, contact_id: str, properties: Dict) -> Dict:
        """
        Update HubSpot contact with enrichment data
        
        Args:
            contact_id: HubSpot contact ID
            properties: Dictionary of properties to update
        
        Returns:
            dict: Response from HubSpot API
        """
        url = f"{self.base_url}/crm/v3/objects/contacts/{contact_id}"
        payload = {"properties": properties}
        
        response = requests.patch(url, headers=self.headers, json=payload)
        response.raise_for_status()
        
        return response.json()
    
    def log_activity(self, contact_id: str, activity_data: Dict) -> Dict:
        """
        Log enrichment activity in HubSpot timeline
        
        Args:
            contact_id: HubSpot contact ID
            activity_data: Dictionary containing activity information
        
        Returns:
            dict: Response from HubSpot API
        """
        url = f"{self.base_url}/crm/v3/objects/contacts/{contact_id}/timeline/events"
        
        payload = {
            "eventTemplateId": "lead-enrichment",  # You'll need to create this template
            "eventType": "LEAD_ENRICHMENT",
            "extraData": activity_data
        }
        
        response = requests.post(url, headers=self.headers, json=payload)
        response.raise_for_status()
        
        return response.json()
    
    def search_contact_by_email(self, email: str) -> Optional[Dict]:
        """
        Search for contact by email address
        
        Args:
            email: Email address to search for
        
        Returns:
            dict: Contact data if found, None otherwise
        """
        url = f"{self.base_url}/crm/v3/objects/contacts/{email}"
        url += "?idProperty=email"
        
        try:
            response = requests.get(url, headers=self.headers)
            if response.status_code == 200:
                return response.json()
            return None
        except Exception:
            return None
    
    def bulk_sync_leads(self, leads: List[Dict]) -> Dict:
        """
        Bulk sync multiple leads to HubSpot
        
        Args:
            leads: List of lead dictionaries
        
        Returns:
            dict: Summary of sync results
        """
        results = {
            "success": 0,
            "failed": 0,
            "errors": []
        }
        
        for lead in leads:
            try:
                # Check if contact exists
                contact_id = None
                if lead.get('email'):
                    existing = self.search_contact_by_email(lead['email'])
                    if existing:
                        contact_id = existing['id']
                
                # Sync lead
                self.sync_lead_to_hubspot(lead, contact_id)
                results["success"] += 1
            except Exception as e:
                results["failed"] += 1
                results["errors"].append({
                    "lead": lead.get('email', 'Unknown'),
                    "error": str(e)
                })
        
        return results

